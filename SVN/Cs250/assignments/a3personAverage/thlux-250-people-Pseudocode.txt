
#######################################################################################
people.cc #main program
#######################################################################################

#include <iostream>
#include <fstream>
#include "Person.h"
#include "People.h"

using namespace std;

//Pre:  argc == 3 arg
//      argv[1] = valid input file
//      argv[2] = valid output file
//Post: The division of the groups of people that creates the lowest
//      difference between the averages of the two groups
int main(int argc, char * argv[]){
  int returnStatus = 0; //init return status
  char * inFileName = argv[1]; //get input file
  ifstream inFile(ifFileName); //create ifstream object
  People wholeGroup = getPeople(inFile); //get whole group
  People groupOne; //Init storage for groupOne
  People groupTwo; //Init storage for groupTwo
  createEvenGroups(wholeGroup, groupOne, groupTwo); //fill the groups
  //      of people
  printResults(groupOne, groupTwo); //print the results
  return(returnStatus);
}

#######################################################################################
PeopleHelper.cc
#######################################################################################

#include <iostream>
#include "People.h"
#include "Person.h"
#include "String.h"
#include "mymath.h"

using namespace std;

//Pre:  inFile is valid, the file has lines with people and their ages
//      space seperated
//Post: People class object filled with the people from the file
People getPeople(ifstream & inFile){
  People wholeGroup;
  while (! inFile.eof()){
    Perons newGuy(inFile.readline()); //get the new person
    wholeGroup.add(newGuy); //add the person to the group
  }
  return (wholeGroup); //return the group of people
}

//Pre:  Three People objects, all valid.  groupOne & groupTwo are
//      empty and wholeGroup holds all people that need to be sorted
//Post: groupOne and groupTwo are filled with the combination of
//      people that has the lowest differnce between the average ages
void createEvenGroups(People & wholeGroup, People & groupOne,
		      People & groupTwo){
  int N = wholeGroup.length(); //get length of wholeGroup
  People Group; //current group
  int toAdd = 3; //the amount of people that need to be added
  int start = 0; //the start index to use to get the next person
  People bGroup; //the best group found so far
  int bestAveDiff; //The smallest average difference found
  recursiveHelper(N, Group, toAdd, start, bGroup, 
		  bestAveDiff, wholeGroup);
  groupOne = bGroup;//set GroupOne
  groupTwo = wholeGroup-bGroup;//set GroupTwo
}

// Pre:  N > 0, toAdd >= 0, start >= 0, bestAveDiff >= 0, The current
//       group, the best group, and the whole group
// Post: best group is set if it is found
void recursiveHelper(int & N, People Group, int toAdd, int & start,
		     People & bGroup, int & bestAveDiff,
		     People & wholeGroup){
  if (toAdd == 0){
    if (computeAveDiff(Group, wholeGroup) < bestAveDiff){ 
      bestAveDiff = aveDiff; //bestAveDist found
      bGroup = Group;//set current group to best
    }
  }
  else{
    while(start <= N-toAdd){ //while not exhausted
      Group.add(wholeGroup.index(start)); //add new start
      recursiveHelper(N, Group, toAdd-1, start+1, //recurse
		      bGroup, bestAveDiff, wholeGroup)
    }
    Group.pop(); //remove start from group
    start ++; //increment start
  }
}

// Pre:  Two People objects defined, satisfying CI
// Post: The average difference between group and the remaining
//       members of wholeGroup
int computeAveDiff(People & group, People & wholeGroup){
  float ave1 = (float) group.averageAge(); //average 1
  float aveTot = (float) wholeGroup.averageAge(); //average of group
  float l1 = (float) group.length(); //length of group
  float lTot = (float) wholeGroup.length(); //length of whole group
  float ave2 = (((ave1/l1)-(aveTot/lTot))*(lTot*l1)); //formula for
  //  average of inverse subgroup
  float aveDiff = sqrt(square(ave1-ave2), .001); //return the square
  //  root of the square accurate to the millionths place
  return (aveDiff);
}

//Pre:  Two valid People class objects with size >= 1 person
//Post: The results of the even split are printed to the command line
void printResults(People & groupOne, People & groupTwo);

#######################################################################################
PeopleHelper.h
#######################################################################################

#include <iostream>
#include "People.h"
#include "Person.h"

using namespace std;

//Pre:  inFile is valid, the file has lines with people and their ages
//      space seperated
//Post: People class object filled with the people from the file
People getPeople(ifstream & inFile);

//Pre:  Three People objects, all valid.  groupOne & groupTwo are
//      empty and wholeGroup holds all people that need to be sorted
//Post: groupOne and groupTwo are filled with the combination of
//      people that has the lowest differnce between the average ages
void createEvenGroups(People & wholeGroup, People & groupOne,
		      People & groupTwo);

//Pre:  Two valid People class objects with size >= 1 person
//Post: The results of the even split are printed to the command line
void printResults(People & groupOne, People & groupTwo);
//Print all of the results in the desired format


#######################################################################################
People.cc
#######################################################################################

#include <iostream>
#include "Person.h"
#include "People.h"

using namespace std;

//Pre:  Default constructor
//Post: max = 0.  size = 0.  CI is satisfied
People::People(){
  max = 0; //set max to zero
  size = 0; //set size to zero
}

//Pre:  oldPeople is defined and follows CI
//Post: deep copy of oldPeople
People::People(People & oldPeople){
  max = oldPeople.max; //get max
  size = oldPeople.size; //get size
  delete [] (thePeople); //delete old memory for thePeople
  thePeople = new Person[max]; //get new memory for people
  for (int i=0; i<size; i++){ //for person in oldPeople
    thePeople[i] = oldPeople.thePeople[i]; //get the person
  }
}

//Pre:  otherGroup is defined and satisfies CI
//Post: deep copy of otherPeopl
People & People::operator=(const People & otherGroup){
  max = otherGroup.max; //get max
  size = otherGroup.size; //get size
  delete [] thePeople; //delete old memory
  thePeople = new Person[max]; //get new memory for people
  for (int i=0; i<size; i++){ //for person in oldPeople
    thePeople[i] = oldPeople.thePeople[i]; //get the person
  }
  return(*this); //return the current People object
}

//Pre:  new is defined
//Post: A copy of new is placed into thePeople, thePeople is
//      expanded if necessary
void People::add(Person newPerson){
  if (max-size <= 0){
    max = max*2 + 1; //get new max
    People * tempPointer = thePeople; //init pointer to old array
    thePeople = new People[max]; //get new heap space
    for (int i=0; i<size; i++){ //for person in thePeopl
      thePeople[i] = tempPointer[i];//copy the Person
    }
    delete [] tempPointer; //delete old memory
  }
  thePeople[size] = newPerson; //copy the new person
  size ++; //increment size
}

// Pre:  size > 0
// Post: the most recently added person is removed from the stack and
//       returned 
Person People::pop(){
  Person returnPerson;
  if (size > 0){ //if can be popped
    size -= 1; //decrement size
    returnPerson = thePeople[size]; //get the last person
    //possible memory leak?  the person at thePeople[size] is never
    // deleted, just no longer counted and will be overwritten
  }
  else{ //no people in thePeople
    cerr << "People.cc\nError: pop from empty People.\n";
  }
  return(returnPerson);//return the person
}

//Pre:  
//Post: Clear all memory, reset to default values
void People::clear(){
  max = 0; //reset max
  size = 0; //reset size
  delete [] thePeople; //free memory in heap, pointer now goes to
  //garbage 
  People * thePeople; //reinitialize pointer to nighting
}

//Pre:  0 <= ind < size
//Post: The person at the index given
Person People::index(int ind) const{
  return(thePeople[ind]); //return the person at the given index
}

//Pre:  
//Post: The average age of all the people in the group
float People::averageAge() const{
  float total = 0.0; //init storage for total, float to represent
  //halves 
  for (int i=0; i<size; i++){ //for person in group
    total += thePeople[i].getAge(); //add the age to the total
  }
  return(total/size); //return the average
}

// Pre:  
// Post: Return the current size
int People::getSize() const{
  return (size); //return size
}

//Pre:  Destructor
//Post: thePeople is freed in memory
~People(){
  delete [] thePeople; //delete stored memory for thePeople
}

#######################################################################################
People.h
#######################################################################################

#ifndef INCLUDED_People
#define INCLUDED_People

#include <iostream>
#include "Person.h"
#include "People.h"

using namespace std;

class People{

 private:

  Person * thePeople; //Array of people
  int size; //size of group
  int max; //maximum capacity

  //CI:  (size <= max) >= 0
  //     thePeople is a pointer to an array in heapspace
  //     thePeople[0] --> thePeople[size] is defined
  //     size is the next available slot in thePeople
 public:

  //Pre:  Default constructor
  //Post: max = 0.  size = 0.  CI is satisfied
  People();

  //Pre:  oldPeople is defined and follows CI
  //Post: deep copy of oldPeople
  People(People & oldPeople);

  //Pre:  otherGroup is defined and satisfies CI
  //Post: deep copy of otherPeopl
  People & operator=(const People & otherGroup);

  //Pre:  new is defined
  //Post: A copy of new is placed into thePeople, thePeople is
  //      expanded if necessary
  void add(Person newPerson);

  // Pre:  size > 0
  // Post: the most recently added person is removed from the stack
  //       and returned 
  Person pop();

  //Pre:  
  //Post: Clear all memory, reset to default values
  void clear();

  //Pre:  0 <= ind < size
  //Post: The person at the index given
  Person index(int ind) const;

  //Pre:  
  //Post: The average age of all the people in the group
  float averageAge() const;

  // Pre:  
  // Post: Return the current size
  int getSize() const;

  //Pre:  Destructor
  //Post: thePeople is freed in memory
  ~People();
};
#endif

#######################################################################################
Person.cc
#######################################################################################

#include <iostream>
#include "Person.h"

using namespace std;

  
//Pre:  Default constructor
//Post: name and age are initialized but still garbage
Person::Person(){}

//Pre:  Copy constructor
//Post: oldPerson is defined and follows CI
//      deep copy of oldPerson is created
Person::Person(Person & oldPerson){
  name = oldPerson.name; //get the name with string copy constructor
  age = oldPerson.age; //get age
}

//Pre:  Defined character array that is the name of the person, a
//      space, and the age of the person ending with a terminator
//      node.
//Post: name is set, age is set
Person::Person(char * nameAndAge){
  int index = 0; //init storage for index
  char chr = nameAndAge[index]; //get current character
  name.reset(); //make sure name is empty and ready to have characters
  //              added 
  while (chr != ' '){//scan for space
    name.add(chr); //add character to na
    index ++; //increment index
    chr = nameAndAge[index]; // get next character
  }
  //ASSERT: name is now the valid name of the person
  //        index is that of the next character after the space
  index ++; //increment index 
  chr = nameAndAge[index]; //get next character
  age = 0; //set age
  while (chr != '\0'){
    newAge = newAge * 10 + (int) chr; //shift age and add new digit
    index ++; //increment index
    chr = nameAndAge[index]; //get next character
  }
  //ASSERT: age is the age of the person
}

//Pre:  otherPerson is defined and satisfies CI
//Post: deep copy of otherPerson
Person & Person::operator=(const Person & otherPerson){
  name = otherPerson.name; //get name
  age = otherPerson.age; //get age
  return(*this); //return the Person
}

//Pre:  Defined character array that is the name of the person
//      ending with a terminator node
//Post: name is set
void Person::setName(char * newName){
  int index = 0; //init storage for index
  char chr = newName[index]; //get current character
  name.reset(); //make sure name is empty and ready to have characters
  //              added 
  while (chr != ' '){//scan for space
    name.add(chr); //add character to na
    index ++; //increment index
    chr = newName[index]; // get next character
  }
  //ASSERT: name is now the valid name of the person
}

//Pre:  integer value for newAge >= 0 is defined
//Post: age is saved
void Person::setAge(int newAge){
  age = newAge; //save value to age
}

//Pre:  
//Post: Age is returned
int Person::getAge() const{
  return(age);//return age
}

//Pre:  Destructor
//Post: Just in case, making sure String destructor is called
Person::~Person(){}

#######################################################################################
Person.h
#######################################################################################

#ifndef INCLUDED_Person
#define INCLUDED_Person

#include <iostream>
#include "Person.h"
#include "String.h"

using namespace std;

class Person{
  
 private:

  String name; //storage for the person's name
  int age;     //storage for the person's age

  //CI:  name is a defined String class object
  //     age is a defined integer >= 0

 public:

  //Pre:  Default constructor
  //Post: name and age are initialized but still garbage
  Person();

  //Pre:  Copy constructor
  //Post: oldPerson is defined and follows CI
  //      deep copy of oldPerson is created
  Person(Person & oldPerson);

  //Pre:  Defined character array that is the name of the person, a
  //      space, and the age of the person ending with a terminator
  //      node
  //Post: name is set, age is set
  Person(char * nameAndAge);

  //Pre:  otherPerson is defined and satisfies CI
  //Post: deep copy of otherPerson
  Person & operator=(const Person & otherPerson);

  //Pre:  Defined character array that is the name of the person
  //      ending with a terminator node
  //Post: name is set
  void setName(char * name);

  //Pre:  integer value for age >= 0 is defined
  //Post: age is saved
  void setAge(int age);

  //Pre:  
  //Post: Age is returned
  int getAge() const;

  //Pre:  Destructor
  //Post: Just in case, making sure String destructor is called
  ~Person();

};

#endif

#######################################################################################
mymath.cc
#######################################################################################

#include <iostream>
#define START_INCREMENT 10
#define INCREMENT_DIVISOR 5.0

using namespace std;

// Pre:  num > 1, inc > 0
// Post: the square root, accurate to thousandths place
float sqrt(float num, float inc){
  float sqrt = 1; //init sqrt value
  float increment = START_INCREMENT; //initial increment
  while (increment >= inc){
    while (square(sqrt) <= num){ //while 1's place squared is less than
      // number
      sqrt += increment; //increment number
    }
    //ASSERT: sqrt**2 > num
    sqrt -= increment; //go to the number smaller than the square root
    increment /= INCREMENT_DIVISOR; //decrement the increment (hahah)
  }
  return(sqrt-increment); //return final square root (immediately less than
  // the real square root of the value
}

// Pre:  num > 1, inc > 0
// Post: the square root, accurate to given increment
int sqrt(int num, int inc){
  int sqrt = 1; //init sqrt value
  while (square(sqrt) <= num){ //while sqrt squared <= num
    sqrt = sqrt+inc; //increment number
  }
  return(sqrt-inc); //return final square root (immediately less than
  // the real square root of the value
}

// Pre:  A defined floating point number
// Post: The number squared
float square(float num){
  return (num * num); //return number squared
}

// Pre:  A defined integer
// Post: The number squared
int square(int num){
  return (num * num); //return number squared
}

#######################################################################################
mymath.h
#######################################################################################

#include <iostream>

using namespace std;

// Pre:  num > 1, inc > 0
// Post: the square root, accurate to thousandths place
float sqrt(float num, float inc);

// Pre:  num > 1, inc > 0
// Post: the square root, accurate to given increment
int sqrt(int num, int inc);

// Pre:  A defined floating point number
// Post: The number squared
float square(float num);


// Pre:  A defined integer
// Post: The number squared
int square(int num);

#######################################################################################
String.cc
#######################################################################################

#include <iostream>
#include "String.h"

using namespace std;

// Default constructor
// PRE:
// POST: currentMax = 0. currentSize = 0. There is one space
//         allocated for the object. theString[0] = '\0'. 
//         CI is satisfied.
String::String () {
  currentMax = 0;
  theString = new char[currentMax + 1];
  theString[0] = '\0';
  currentSize = 0;
}

// Constructor given a string
//Pre:  Pointer to string is given
//Post: The given string is stored
String::String(char * str) {
  currentMax = 0;
  theString = new char[currentMax+1];
  theString[0] = '\0';
  currentSize = 0;
  while (str[currentSize] != '\0'){
    add(str[currentSize]);
  }
}

//Pre:  aString is defined and follows CI
//Post: Deep copy of aString created
String::String(String & aString){
  currentMax = aString.currentMax; //get value for current max
  delete (thString); //delete old saved array
  theString = new char[currentMax+1]; //create new array for storage
  //with + 1 for the terminator node
  for (int i=0;i<aString.currentSize; i++){ //for value in aString
    theString[i] = aString.theString[i]; //copy the char
  }
  currentSize = aString.currentSize; //set current size
  theString[currentSize] = '\0'; //set the last char to the terminator
  //node 
}

//Pre:  str is a defined string object
//Post: This object is a deep copy of str
//      RV: a reference to this object
String & String::operator=(const String & str){
  currentMax = str.currentMax; //get max
  currentSize = str.currentSize; //get size
  delete (theString); //delete old allocated memory
  theString = new char[currentMax+1]; //get new memory
  for (int i=0; i<currentSize; i++){ //for char in str
    theString[i] = str.theString[i]; //copy
  }
  theString[currentSize] = '\0';
  return(*this); //return lvalue
}
//lvalue --> value to the left of an operation
//rvalue --> value to the right of an operation

// Pre:  str is a defined output stream. aString is a defined String
//       object satisfying the CI.
// Post: str contains the character array stored in a String
//       RV is resulting output stream
ostream & operator<<(ostream & str, const String & aString){
  str << aString.theString; //add current string to stream
  return (str); //return stream
}


//Pre:  The array of characters to be filled of length stop-start + 1
//      start & stop are indices in theString
//Post: The given array is filled with values from start to stop
void String::fillArray(char * array, int start, int stop) const{
  for (int i=start ; i < stop; i++){
    array[i-start] = theString[i]; //shift all values over to
                                         //appropriate indices and
				         //transfer them to the given
				         //array of characters
  }
  array[stop-start] = '\0'; //add terminator
}

//Pre:  Integer index for starting the search,
//      and the character to search for in theString
//Post: The number of characters from [start, char)
int String::countToNextChar(int start, char ch) const{
  int curr = start; //temp place holder
  char chr = theString[curr]; //current character
  while ((chr != ch)&(chr != '\0')){ //current != search
    curr ++; //increment place holder
    chr = theString[curr]; //get new character
  }
  return (curr - start); //+1 to be inclusive on start
}

//Pre:  A character to divide the string by is given, and a reference
//      to an integer that will hold the size of the return array
//Post: An array of character arrays
char ** String::splitBy(char ch, int & length) const{
  length = count(ch); //save length to the given reference,
  //      length is the number of array references that will be
  //      present
  int curr = 0; //place holder in stringArray
  char ** stringArray = new char*[length]; //get heap space mem for
  //      array 
  int size; //variable for holding the size of the current string
  for (int i=0; i < currentSize; i++){
    size = countToNextChar(i, ch); //count of current array
    stringArray[curr] = new char[size+1]; //create pointer to new
                                          //      array 
    fillArray(stringArray[curr], i, size+i); //fill the array
    i = i+size; //increment i
    curr ++; //increment current index
  }
  //Assert:   The whole file has been added
  //          The characters that were split by are removed
  //          The character arrays each hold a sub string
  //          Length has been set to the number of strings
  return (stringArray);
}

//Pre:  array of size >= (currentSize+1)
//Post: The given array is filled with the values from theString
void String::retExactArray(char array[]) const{
  for (int i=0; i<currentSize; i++){
    array[i] = theString[i];
  }
}

//Pre:  
//Post: A new array of exact size is built in heap space and returned
char * String::retExactArray() const{
  char * returnArray = new char[currentSize+1];
  for (int i=0; i<currentSize; i++){
    returnArray[i] = theString[i];
  }
  return (returnArray);
}

//Pre:  A character is given
//Post: The number of occurances of that character is counted in
//      theString
int String::count(char ch) const{
  int count = 0; //init count
  for (int i=0; i < currentSize; i++){ //cycle string
    if (theString[i] == ch){ //if ch found
      count ++; //add to count
    }
  }
  return (count); //the # occurances
}

//Pre:  
//Post: The current length of the string is returned as an integer
int String::length() const{
  return (currentSize);
}

// Pre:  Integer of index in array is given, the index must be les
//       than current size or else an empty character is returned
// Post: The character at that index is returned
char String::index(int index) const{
  char returnCharacter;
  if (index > currentSize){
    returnCharacter = '\0';
  }
  else{
    returnCharacter = theString[index];
  }
  return(returnCharacter);
}

// Output member functions

// PRE: This String object is defined and satisfies the CI.
// POST: OS contains a newline followed by the values of currentMax,
//       currentSize and the characters in theString followed by a
//       newline. 
void String::debugPrint () const  {
  cout << endl;
  cout << "currentMax = " << currentMax << "; "
       << "currentSize = " << currentSize << "; "
       << "current string = ";
  for (int i = 0; i < currentSize; i++) {
    cout << "(" << i << ", *" << theString[i] << "*) ";
  }
  cout << "(" << currentSize;
  if (theString[currentSize] == '\0') {
    cout << ", *EOS*)";
  }
  else {
    cout << ", *NOT EOS*)";
  }
  cout << endl;
}

// PRE: This String object is defined and satisfies the CI.
// POST: OS contains the characters in this string.
void String::print () const {
  cout << theString;
}

// PRE: This String object is defined with values 
//       currentMax = M, currentSize = S, and satisfies the CI.
// POST: ch is defined. 
//       theString[0]..theString[S-1] are the same as before.
//       theString[S] = ch
//       theString[S+1] = '\0'
//       The result object satisfies the CI.
void String::add (char ch) {
  if ((currentMax - currentSize) <= 0){ //if the current array is full
    //       ( '<= 0' is used simply for safety but unnecessary)
    char * tempString = theString; //create a temp pointer to the old
    //       string
    theString = new char[(currentMax+1)*2]; //create a new arry twice as
    //       large for theString
    for (int i=0; i<currentSize; i++){ //Cycle through old string
      theString[i] = tempString[i]; //transfer values to new array
    }
    currentMax = (currentMax*2)+1; //Double the size of current max
    //       and add one ( - terminator node)
    delete tempString; //Delete old useless array
  }
  theString[currentSize] = ch; //Add new character
  currentSize ++; //increment currenSize
  theString[currentSize] = '\0'; //Add terminator
}

// Pre:  
// Post: All values are reset back to initial settings
void String::reset(){
  delete (theString);
  currentMax = 0;
  theString = new char[currentMax + 1];
  theString[0] = '\0';
  currentSize = 0;
}

//Pre:  theString exists as a pointer to an array in heap space
//Post: The heap space is freed
String::~String(){
  delete (theString);
}

#######################################################################################
String.h
#######################################################################################

#ifndef INCLUDED_String
#define INCLUDED_String

#include <iostream>

using namespace std;

class String {
  
 private:
  
  char * theString; // pointer to the space allocated for the array of
		    // characters.
  int currentMax;   // the maximum number of characters that can be
		    // currently accommodated in this String object.
  int currentSize;  // the number of characters currently in this
		    // String object.

  // CI: theString points to space allocated for at least one
  //       character.
  //     currentMax >= 0. theString points to space allocated for
  //       currentMax + 1 characters (one character for EOS)
  //     currentSize = 0. currentSize <= currentMax.
  //       theString[0]..theString[currentSize-1] is
  //       defined. theString[currentSize] is EOS


 public:

  // Default constructor
  // PRE:
  // POST: currentMax = 0. currentSize = 0. There is one space
  //         allocated for the object. theString[0] = '\0'. 
  //         CI is satisfied.
  String();

  // Constructor given a string
  //Pre:  Pointer to string is given
  //Post: The given string is stored
  String(char* str);

  //Pre:  aString is defined and follows CI
  //Post: Deep copy of aString created
  String(String & aString);

  //Pre:  str is a defined string object
  //Post: This object is a deep copy of str
  //      RV: a reference to this object
  String & operator=(const String & str);

  // Pre:  str is a defined output stream. aString is a defined String
  //       object satisfying the CI.
  // Post: str contains the character array stored in a String
  //       RV is resulting output stream
  friend ostream & operator<<(ostream & str, const String & aString);

  //Pre:  The array of characters to be filled of length stop-start +
  //      1 
  //      start & stop are indices in theString
  //Post: The given array is filled with values from start to stop
  void fillArray(char * array, int start, int stop) const;

  //Pre:  Integer index for starting the search,
  //      and the character to search for in theString
  //Post: The number of characters from [start, char)
  int countToNextChar(int start, char ch) const;

  //Pre:  A character to divide the string by is given, and a
  //      reference 
  //      to an integer that will hold the size of the return array
  //Post: An array of character arrays
  char ** splitBy(char ch, int & length) const;

  //Pre:  array of size >= (currentSize+1)
  //Post: The given array is filled with the values from theString
  void retExactArray(char array[]) const;

  //Pre:  
  //Post: A new array of exact size is built in heap space and returned
  char * retExactArray() const;

  //Pre:  A character is given
  //Post: The number of occurances of that character is counted in
  //      theString
  int count(char ch) const;

  //Pre:  
  //Post: The current length of the string is returned as an integer
  int length() const;

  // Pre:  integer of index in array is given, the index must be les
  // than current size or else an empty character is returned
  // Post: The character at that index is returned
  char index(int index) const;

  // Output member functions
  // PRE: This String object is defined and satisfies the CI.
  // POST: OS contains a newline followed by the values of currentMax,
  // currentSize and the characters in theString followed by a
  // newline. 
  void debugPrint () const;

  // PRE: This String object is defined and satisfies the CI.
  // POST: OS contains the characters in this string.
  void print () const;

  // Modifiers

  // PRE: This String object is defined with values 
  //       currentMax = M, currentSize = S, and satisfies the CI.
  // POST: ch is defined. 
  //       theString[0]..theString[S-1] are the same as before.
  //       theString[S] = ch
  //       theString[S+1] = '\0'
  //       The result object satisfies the CI.
  void add (char ch);

  // Pre:  
  // Post: All values are reset back to initial settings
  void reset();

  //Pre:  theString exists as a pointer to an array in heap space
  //Post: The heap space is freed
  ~String();
  
};
#endif
