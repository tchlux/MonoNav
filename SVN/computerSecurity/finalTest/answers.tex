\documentclass[a4paper, 11pt]{article}
%start off latex files with the specifications of the entire document,
%[paper, font]{class type}

\usepackage[margin=1in]{geometry} %for 1 inch margins on the edges
\usepackage{setspace} %for double spacing

\title{Final Exam}
\author{Thomas Lux}
\date{December 12th, 2013}

\begin{document} %start doc
\maketitle %insert the title

\singlespacing %begin the single spacing


%Begin Exam Answers
\begin{enumerate}

  %% Question 1
\item
  %% Part A  
  Confidentiality: Only people with permission can access data.
  \begin{enumerate}
  \item
    Breaking into a password storage file and stealing passwords.
  \item
    Listening in on communcations between two other parties.  Not to
    be confused with Man-in-the-Middle, strictly listening.
  \item
    Any breach of encryption by a 3rd party.
  \end{enumerate}
  
  %% Part B
  Integrity: Communication is clearly with a valid source.
  \begin{enumerate}
  \item
    Phishing: Sending out information saying that you are another
    source, and requesting users click on a link or type in their
    password.
  \item
    Man-in-the-Middle attack, where a 3rd party intercepts all
    communications between two communicants and has seperate key value
    pairs with each.
  \end{enumerate}

  %% Part C
  Availability: Users should have the ability to access their data.
  \begin{enumerate}
  \item
    (Distributed) Denial of Service, when a computer or set of
    computers is used to repeatedly access a server/site such that no
    other users are able to access the server/site.  This is attack is
    used to overwhelm a host.
  \item
    DNS poisoning, domain name services are overwritten or diverted so
    that when the name of a given website is given, the user is
    erdirected to the incorrect IP address. 
  \end{enumerate}
  %% End Question 1

  %% Question 2    
\item
  \begin{enumerate}
    %% Part A
  \item
    Yes, because the same keys will be used to encrypt and decrypt the
    message that is being delivered.

    %% Part B
  \item
    A = 1 \\
    B = Ceaser Encryption Key \\
    M = 26, the length of the alphabet

    %% Part C
  \item
    $ 
    (( C_n - B ) \times \mbox{Multiplicative inverse } A)
    \mbox{ \% M }
    $

    %% Part D
  \item
    Check out the program ``prob2partd.cc''\\

  \end{enumerate}
  %% End Question 2

  %% Question 3
\item
  \begin{enumerate}
    %% Part A
    \item
      The difference between symmetric key cryptographic systems and
      public-key cryptographic systems is the number of keys used for
      interactions.  Symmetric key cryptography has a seperate key for
      every communication, where as public key uses the same key for
      all communicationss.

      %% Part B
    \item
      In a symmetric key cryptographic system, since the same key is
      used for encryption and decryption and every message must have
      it's own unique key to be secure, this means that we would
      need $O(n^2)$ keys in order to communicate securely with
      everyone.  Take the internet for example, with k servers, and n
      people, we would need $\frac{ (k \times n)\cdot((k \times n) -
        1)}{2}$, but that's way too many! \\\\ In the public key
      system, we no longer need unique keys for all communications,
      everyone else just needs our public key so they can encrypt, and
      then only we can decrypt.  A theoretical problem with this
      system is that if someone does manage to break our private key,
      and can use it, then they can now decipher all information that
      is delivered with us as the intended recipient.

      %% Part C
    \item
      A programmer would be primarily concerned with some other
      aspects of the encryption, primarily the time required to
      perform these actions.  Symmetric key encryption is much faster
      for encryption and decryption, so it is frequently the case that
      asymmetric encryption is only used for initial communication,
      then from there on out symmetric key encryption is used.

      %% Part D
    \item
      One possible solution to the runtime of the asymmetric key
      encryption is to come up with a formula that factors any
      given number in constant time!!  Then the whole internet would
      be insecure and broken!

  \end{enumerate}
  %% End Question 3

  %% Begin Question 4
\item
  Hmmmm ... beep beep, boop, bop, bop, boooooooop, ...\\
  $n = (491 \times 397) = 194927)$\\
  $p = 491 \mbox{     } q = 397$\\
  $\mbox{phi}(n) = (p-1)(q-1) = 194040$\\
  Encryption key: 47 \\\\
  EEA:\\
  n1\hspace{8mm}   n2\hspace{8mm}  q\hspace{10mm} x \hspace{10mm} y \\
  491\hspace{6mm} 397\hspace{6mm}  1\hspace{10mm} -34\hspace{8mm} 42\\
  397\hspace{6mm}  94\hspace{8mm}  4\hspace{10mm} 8\hspace{11mm} -34\\
  94\hspace{8mm}   21\hspace{8mm}  4\hspace{10mm} -2\hspace{11mm} 8 \\
  21\hspace{8mm}   10\hspace{8mm}  2\hspace{10mm} 1\hspace{12mm}  -2\\
  10\hspace{8mm}    1\hspace{9mm} 10\hspace{9mm}  0\hspace{12mm}  1 \\
  1\hspace{10mm}    0\hspace{9mm} \hspace{13mm}   1\hspace{12mm}  0 \\
  \\Multiplicative inverse: -34 or 194006\\
  Either 47 or 194006 could be the public key with the other as the
  private key.
  %% End Question 4


  %% Question 5
\item
  \begin{enumerate}
    %% Part A
    \item
      Check out the program ``prob5parta.cc''\\

      %% Part B
    \item
      No, the hash function has neither confusion, diffusion, nor a
      considerable amount of entropy.  The relationship between input
      and output is very simplistic, small changes in the input do not
      change the output drastically, and the output does look
      different than the input, but that is only a format, that can be
      easily read to be the same thing.
  \end{enumerate}
  %% End Question 5
      
  %% Begin Question 6
\item
  \begin{enumerate}
    %% Part A
    \item
      SSL and TLS are able to authenticate with a process similar to
      the following:\\\\
      Phase 1: Hello, nice to meet you\\
        Client hello, security capabilities, random nonce\\
        Server hello, security capabilities, random nonce\\\\
      Phase 2: Server side communication\\
        certificate delivery (signed by some trusted 3rd party)\\
        public key\\
        (optional) certificate request\\
        hello done message\\\\
      Phase 3: Client side communication\\
        (optional) certificate\\
        client key\\
        (optional) certificate verification\\\\
      Phase 4:\\
        Client - change cipher done\\
        Server - change cipher done\\
        Begin encrypted comunication\\\\
      Take note that this establishes a shared symmetric key to make
      the encryption faster.  The program will use the random nonce
      information to generate the shared symmetric key.  The server
      computes the key and sends it encrypted with the client's public
      key so only the client can know the symmetric key.

      %% Part B
    \item
      Some additional mechanisms that must be in place for all of this
      to work are valid and compatible security capabilities on both
      the server and the client side of the communication.  This also
      depends on the third party that authenticates the certificates
      to be entirely secure.
        
  \end{enumerate}
  %% End Question 6

  %% Question 7
\item
  Check out the program ``prob7parta.cc''\\  
  %% End Question 7

  %% Question 8
\item
  \begin{enumerate}
    %% Part A
    \item
      The purpose of these attacks was to gain access to a different
      account that has higher privilege than the current user.  This
      could gain access to files that were locked before.

      %% Part B
    \item
      The element that allowed shells to be opened with root privilege
      was that root was the one calling the open-new-shell command.
      When the current user opens a new shell, it opens the shell as
      the current user.  This is where much of the ``code injection''
      became useful.  It allowed us to \textit{trick} the root into
      opening a new shell for us.

  \end{enumerate}
  %% End Question 8

  %% Question 9
\item
  \begin{enumerate}
    %% Part A
    \item
      In python an Java, all of the memory allocation is done by the
      language, this ensures that users (even programmers) cannot
      overflow an array of allocated memory.  In C and C++ this flaw
      was escaped with canary values, used to pad the return addresses
      after function calls ensuring that the return address was not
      overwritten during the call.

    \item
      The primary expense of these mechanisms is time, checks must be
      made to ensure that values were not overwritten, and in Python
      and Java, more checks must be made to make sure that arrays are
      not being overfilled.  All of these checks weighs down programs,
      and makes execution take longer.  There is also some portion of
      extra space that is required as well.

  \end{enumerate}
  %% End Question 9


%End exam answers
\end{enumerate}
\end{document}
