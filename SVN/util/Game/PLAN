     =============================
          IMPLEMENTATION PLAN     
     =============================

===============================================
    Phase 1     :: Run with multiple shaders   
===============================================

-> Get the shader for Vertex, Texture, and Normal working
-> Get the shader for Vertex, and Normal working
-> Get the shader for Just vertices working
-> Get the shader for vertices and textures working

$ Test each shader on single executions

-> Read openGL documentation to find out how to keep a list of
   different shaders
-> Look into the viewGL class, add a member data set for the
   individual program ID's in an array for running, or just have the
   program ID set in the model on initialization
---> Consider access to these ID's, the Model will have a specific
     program ID with it, and will have vertex, normal, and text ID's

$ Test a simple obj file with just vertices
$ Test an obj file with vertices and normals
$ Test an obj file with vertices normals and texture
$ Test an obj file with vertices and texture

$ Test with multiple models simultaneously that use different shaders

====================================
    Phase 2:  Update Draw to GL3    
====================================

-> Make static public member data in Model class that holds camera
-> Split camera matrices into perspecive and view
-> Make the clone set the Matrices for GL
---> glUniformMatrix4fv(matrix_id (attribute name in shader),
                        1, GL_TRUE (Row major order), 1-D array data)

$ Test the set of projection matrices, perspective and view

-> Make sure the translation and rotation are applied in the -> order

$ Test the movement of the camera and the rotation of the camera

-> Make a Controls class that holds member data and functions for all
     of the controls of the clones and of the camera
-> Link the controls of camera and clone to that class by passing them
     in the main loop

$ Test camera movement, rotation
$ Test model movement, rotation

-> Remove the extra GLorhto commands in viewGL, make the viewGL window
   complain if the camera is not set in the game

$ Test without camera, and then with camera

===========================================================
     Phase 3:  Collision detection with Bounding Boxes     
===========================================================

-> Find the min and max x vertices when loading the Model and the min
   and max y locations
-> Use these two coordinate pairs (minx,miny,minz)(maxx,maxy,maxz) to
   calculate all 8 corners of the bounding box and save it to member
   data 

$ Test this on a simple obj that does not have a z or y axis
$ Test this on obj that does not have z axis
$ Test on full obj

-> Calculate the normals for these bounding boxes (Three per box)

$ Test this on a simple obj that does not have a z or y axis
$ Test this on obj that does not have z axis
$ Test on full obj

-> Uncomment the collision code and use the bounding box of the model
   class maker of the clone.  Find a simple way to apply the
   transformations to the points of the bounding box and then test if
   they are overlapping

$ Test collision detection code for functionality


	============================
	     PROJECTS AND GOALS     
	============================

-> Fix the file reading so that it reads vertex/texture/normal
---> Has to account for vertex//normal and just vertex
---> Have to write code that can calculate normals from three verts

-> Make one shader for each case (4) and load and compile each
---> 4 program ID's one for each shader (Based of the file that was
                                        read, use the appropriate
---> look at file (/src/final.frag) after course stuff
---> In draw loop, need to load the appropriate shader program
                                        shader)
---> Get the new .vert and .frag from the site that handle all cases

-> Pass my camera matrix to the draw function for Clone somehow
-----> Make a pointer to the camera static in the Model class
---> Remove usage of the GL_PROJECTION matrix stack
---> Camera data set stays in viewGL but the actual loading happens in
     the Clone class
---> Remove all GLOrtho and matrix stuff from window begin draw

-> Write Collision detection code for the Clone
---> Add a set of 8 vertices that are the bounding box of a Model and
     is created at load time
---> Make sure the Clone has access to that bBox
---> Create local normal vectors/vertices for that bBox
---> Run the collison detection code on those normals and vertices

