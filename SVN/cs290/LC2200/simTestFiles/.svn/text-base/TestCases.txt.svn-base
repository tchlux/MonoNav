Test cases

=======================================================================
NOTES: 
  Tests 1 and 2 were done during development to check if the
  correct parts of the words were being extracted. 

  All the files from t2 onwards can be loaded into memory and run
  (stepped).

  All the "programs" in the test files assume that the registers are
  all initialised to zero. So, each of those programs must be run by
  starting the simulator and loading the programs.

  Test files t2 through t9 include the halt instruction at the end. You
  can step through these programs one (or more) instruction(s) at a
  time, or run these programs to completion. 

  The files t10 through t32 do not include the halt instruction at the
  end; these programs must be stepped through.
=======================================================================

1. Test to make sure that correct word is fetched from memory.

2. Test to make sure that each part of the word is decoded correctly. 
   File : t1
   a. Opcode, Reg. X, Reg. Y, Reg. Z (is present), signed immediate or
      address offset.
      0x3b500011 - opcode: 3, X = 11, Y = 5, Z = 1, value = 17
      0x3b5ffff1 - opcode: 3, X = 11, Y = 5, Z = 1, value = -15

3. Test addi.
   File : t2
      addi $t0, $a0, 10   0x2630000a
      addi $v0, $a0, -5   0x223ffffb
      halt                0x70000000

   Expect $t0 to be 10 and $v0 to be -5

4. Test add
   Four cases. add two positives, 
               add two negatives, 
               add one negative and one negative to result in positive, 
               and one negative and one negative to result in negative.
   Case 1: File: t3
      addi $a1, $a2, 5       0x24500005
      addi $s0, $s1, 7       0x29a00007
      add  $s2, $a1, $s0     0x0b400009
      halt                   0x70000000

      Expect s2 = 12 (0x0000000c)

   Case 2: File: t4
      addi $t0, $t1, -8      0x267ffff8
      addi $t2, $k0, -12     0x28cffff4
      add  $v0, $t0, $t2     0x02600008
      halt                   0x70000000

      Expect v0 = -20 (0xffffffec)

   Case 3: File: t5
      addi $t0, $t1, 15      0x2670000f
      addi $t2, $k0, -13     0x28cffff3
      add  $v0, $t0, $t2     0x02600008
      halt                   0x70000000

      Expect v0 = 2 (0x00000002)

   Case 4: File: t6
      addi $t0, $zero, 15      0x2600000f
      addi $t2, $zero, -26     0x280fffe6
      add  $v0, $t0, $t2       0x02600008
      halt                     0x70000000

      Expect v0 = -11 (0xfffffff5)

5. Test nand
      File: t7
      addi $t0, $zero, 15    0x2600000f
      addi $t2, $zero, -26   0x280fffe6
      nand $v0, $t0, $t2    0x12600008
      halt                   0x70000000

      Expect v0 = -7 (0xfffffff9)

6. Test lw
      Six cases. Loading from an address that is not a word boundary,
                 Positive, negative and 0 as offset value.
                 Effective address is negative or larger than memory
                 size. 
       
      Case 1: File: t8
      addi $a0, $zero, 8              0x23000008
      lw $v0, 2($a0)		      0x32300002
      halt                            0x70000000

      Expect (want) the simulator to give us an error.


      Case 2: File: t9
      addi $t1, $zero, 0x123ab         0x270123ab
      sw $t1, 20($zero)                0x47000014
      addi $a0, $zero, 16              0x23000010
      lw $v0, 4($a0)                   0x32300004
      halt                             0x70000000

      Expect that 0x123ab is loaded into $v0
 
      Case 3: File: t10
      addi $t1, $zero, 0x123ab          0x270123ab
      sw $t1, 16($zero)                 0x47000010
      addi $a0, $zero, 20               0x23000014
      lw $v0, -4($a0)                   0x323ffffc

      Expect that 0x123ab is loaded into $v0

      Case 4: File: t11
      addi $t1, $zero, 0x123ab          0x270123ab
      sw $t1, 16($zero)                 0x47000010
      addi $a0, $zero, 16               0x23000010
      lw $v0, 0($a0)                    0x32300000

      Expect that 123ab is loaded into $v0

      Case 5: File: t12
      addi $a0, $zero, 12               0x2300000c
      lw $v0, -16($a0)                  0x323ffff0

      Expect error because address is negative.

      Case 6: File: t13
      Start simulator with 20 bytes of memory.
      lw $v0, 32($zero)                 0x32000020

      Expect error because address is too large.

7. Test sw. (BEFORE lw)
      Six cases. Storing to an address that is not a word boundary,
                 Positive, negative and 0 as offset value.
                 Effective address is negative or larger than memory
                 size. 

      Case 1: File: t14
      addi $a0, $zero, 8              0x23000008
      sw $v0, 2($a0)		      0x42300002

      Expect (want) the simulator to give us an error.


      Case 2: File: t15
      addi $v0, $zero, 0x123ab         0x220123ab
      addi $a0, $zero, 8               0x23000008
      sw $v0, 4($a0)                   0x42300004

      Expect that 123ab is stored at address 12.
 
      Case 2a: File: t15a
      addi $v0, $zero, 0x123ab         0x220123ab
      addi $a0, $zero, 7               0x23000007
      sw $v0, 5($a0)                   0x42300005

      Expect that 123ab is stored at address 12.
 
      Case 3: File: t16
      addi $v0, $zero, 0x123ab          0x220123ab
      addi $a0, $zero, 16               0x23000010
      sw $v0, -4($a0)                   0x423ffffc

      Expect that 123ab is stored at address 12

      Case 4: File: t17
      addi $v0, $zero, 0x123ab          0x220123ab
      addi $a0, $zero, 12               0x2300000c
      sw $v0, 0($a0)                    0x42300000

      Expect that 123ab is stored at address 12

      Case 5: File: t18
      addi $a0, $zero, 12               0x2300000c
      sw $v0, -16($a0)                  0x423ffff0

      Expect error because address is negative.

      Case 6: File: t19
      Start simulator with 20 bytes of memory.
      sw $v0, 32($zero)                 0x42000020

      Expect error because address is too large.

8. Test beq
     Six cases: equal values and unequal values, negative offset and
                 effective address is not a word boundary, a negative
                 address and an address larger than memory size. 
      Case 1: File t20
        addi $t0, $zero, 2          0x26000002
        addi $t2, $zero, 2          0x28000002
 done:  beq  $t0, $t2, 4            0x56800004

        Expect PC = 16
  
      Case 2: File t21
        addi $t0, $zero, 2          0x26000002
        addi $t2, $zero, 3	    0x28000003
        beq  $t0, $t2, 4	    0x56800004

        Expect PC = 12

      Case 3: File t22
        addi $t0, $zero, 2          0x26000002
        addi $t2, $zero, 2	    0x28000002
        beq  $t0, $t2, -4	    0x568ffffc

        Expect PC = 8

      Case 4: File t23
        addi $t0, $zero, 2          0x26000002
        addi $t2, $zero, 2	    0x28000002
        beq  $t0, $t2, 2	    0x56800002

        Expect error because eff. address is not on a word boundary.

      Case 5: File t24
        addi $t0, $zero, 2          0x26000002
        addi $t2, $zero, 2	    0x28000002
        beq  $t0, $t2, -20	    0x568fffec

        Expect error because eff. address is less than 0.

      Case 6: File t25
        Start simulator with 20 bytes of memory
        addi $t0, $zero, 2          0x26000002
        addi $t2, $zero, 2	    0x28000002
        beq  $t0, $t2, 20	    0x56800014

        Expect error because eff. address is larger than memory size.

9. Test jalr
     Four test cases: One with different registers, one with same
                      registers, contents of reg. X is too large, 
		      contents of reg. X is not a word boundary.
 
      Case 1: File t26
        addi $a0, $zero, 4          0x23000004
        jalr $a0, $v0               0x63200000

        (1. Copy current PC to the return register ($v0)
	    AND THEN
	 2. Set PC to be the contents of the jump register ($a0))

        Expect v0 = 8 and PC = 4

      Case 2: File t27
        addi $a0, $zero, 12          0x2300000c
        jalr $a0, $a0                0x63300000

        Expect $a0 = 8, PC = 8 (not 12).

      Case 3: File t28
        Start simulator with 20 bytes of memory
        addi $ra, $zero, 24           0x2f000018
        jalr $ra, $v0                 0x6f200000

        Expect error because eff. address is too large.


      Case 4: File t29
        Start simulator with 20 bytes of memory
        addi $ra, $zero, 5           0x2f000005
        jalr $ra, $v0                0x6f200000

        Expect error because eff. address is not a word boundary.

10. Test in

    Positive number
    Negative number
    Out of range

    Case 1: File t30
       in $a0                        0xc3000000

    User prompt is shown.
    Try three different inputs.
    $a0 is the input number.

11. Test out
    Positive number
    Negative number

    Case 1: File t31
       addi $a0, 10                  0x2300000a
       out $a0                       0xd3000000

    Expect 10 to be printed.

    Case 2: File t32
       addi $a0, -5                  0x230ffffb
       out $a0                       0xd3000000

    Expect -5 to be printed.

12. Test la
    Out of bounds address (given by offset)
    Not a word boundary.
    Forward reference (positive offset)
    Backward reference (negative offset)
    
    Case 1: Address negative (File t33)

       la $a0, -12                   0xe3fffff4

       Expect $a0 is -8 (0xfffffff8)

    Case 2: (File t34)

       Start the simulator with 20 bytes of memory.
       la $a0, 20                    0xe3000014
  
       Expect $a0 is 24 (0x00000018)

    Case 3: (File t35)

       la $a0, 3                     0xe3000003

       Expect $a0 is 7 (0x00000007)

    Case 4: (File t36)

       la $a0, 12                    0xe300000c

       Expect $a0 is 16 (0x00000010)

    Case 5: (File t37)
  
       add $a0, $zero, $zero         0x03000000
       la $a0, -8                    0xe3fffff8

       Expect $a0 is 0 (0x00000000)

       

