PLANNING FOR IMPLEMENTATION

**findMe is a file that does not exist
**inOut is an assembly program that requests input and then out's that input, has 3 words, 3 cycle runtime

	//=================
	//     Phase 1     
	//=================

--> Implement loading of data from configuration file
--> Add the functionality to specify a file and execute it in one command
--> Check for number of arguments to see what is requested
--> Add error statements for file does not exist (this replaces invalid command error)

->Case 1: === Create Simulator with .conf file === Accurate listing of memory
::Test::
$ ./LC2200
 Memory size = 1024 bytes (256 words).

->Case 2: === Single argument === no file === invalid filename
::Test::
>findMe
>ERROR: File not found.


->Case 3: === Two args, second is & === no file === invalid filename
::Test::
>findMe &
>ERROR: File not found.


->Case 4: === > 2 args, second is & === invalid command
::Test::
>inOut & ssss
>ERROR: Invalid command.


->Case 5: === > 1 arg, second is not & === invalid command
::Test::
>inOut ssss hello
>ERROR: Invalid command.

::Test::
>inOut &&
>ERROR: Invalid command.


	//=================
	//     Phase 2     
	//=================

--> Create PCB class
--> Create System Queue class (for holding PCB's in future) (has a head or "current")
--> Create System clock
--> Create pointer to current PCB (This will be the head of the system queue)
--> Implement Completed process queue
--> Print program information on system exit

->Case 1: === normal single program execution === exit === data and results
::Test::
>inOut (Use a simple test assembled program with single input and output)
? 3
3
>quit
=== START :::  Information report =====
PID  ::  Response Time  ::  Run Time  ::  Wait Time

1  ::  3  ::  3  ::  0

=== END ::::  Information report =====

->Case 2: === two program execution === exit === data and results
::Test::
>inOut
? 3
3
>inOut
? 5
5
>quit
=== START :::  Information report =====
PID  ::  Response Time  ::  Run Time  ::  Wait Time

1  ::  3  ::  3  ::  0

2  ::  3  ::  3  ::  0

==== END ::::  Information report =====


     //=================
     //     Phase 3     
     //=================

--> Display PID with input and output (modification)
--> Implement Ready Queue
--> Add timeSlice counter
--> Create FreeMemory class
--> Implement FreeMemory class (for deciding where progs go)
---->  when loaded, find size of file, add (stack size) number of words,
---->  and store start location of stack (in PCB)  (set SP to that value on run)
--> Implement PCB swap between time-slices
--> create and implement queue command  (print PCB and see succseful listing of stack pointer (at the end of that program's space))

->Case 1: === normal single program execution === exit === data and results
::Test::
>inOut
PID 1: ? 3
PID 1: 3
>queue
=== START :::  PCB report =====
---PID: 1---
PC: 4
Frame Pointer: 1 (look into this? what is correct?)
Owns I/O: 1
End Address: 76 (3 words assembled + 16 words stack)
Start Time: 1
End Time: 4
Run Time: 3
::Registers::
r0 00000010
------------
==== END ::::  PCB report =====
>quit
=== START :::  Information report =====
PID  ::  Response Time  ::  Run Time  ::  Wait Time

1  ::  6  ::  6  ::  0

==== END ::::  Information report =====

->Case 2: === two program execution === exit === data and results
::Test::
>inOut
PID 1: ? 3
PID 1: 3
>inOut
PID 2: ? 10
PID 2: 10
>quit
=== START :::  Information report =====
PID  ::  Response Time  ::  Run Time  ::  Wait Time

1  ::  6  ::  6  ::  0

2  ::  12  ::  6  ::  6

==== END ::::  Information report =====


    //=================
    //     Phase 4     
    //=================

--> Implement I/O Queue (hold's processes that are attempting to use I/O)
--> Modify 'in' and 'out' to check 'owns I/O'
--> Create 'run in background' command with no ownership of I/O
--> Create 'fg' command to bring a process to the foreground
--> Create 'jobs' command to list all PID's and states (which queue a process is in)

->Case 1: === execute in background === jobs (list I/O queue) === fg PID === Execution of I/O
::Test::
>inOut &
>jobs
=== START :::  Jobs report =====
PID  ::  State  ::  Owns I/O

1  ::  In I/O queue  ::  False

==== END ::::  Jobs report =====
>fg 1
PID 1: ? 3
PID 2: 3

->Case 2: === execute first in bg, second in fg === jobs === fg first
::Test::
>inOut &
>inOut
PID 2: ? 4
PID 2: 4
>jobs
=== START :::  Jobs report =====
PID  ::  State  ::  Owns I/O

1  ::  In I/O queue  ::  False

2  ::  In Completed queue :: False

==== END ::::  Jobs report =====
>fg 1
PID 1: ? 3
PID 1: 3


	//=================
	//     Phase 5     
	//=================

--> Modify 'step', 'cpu'
--> Create 'kill', 'suspend', 'restart', 'freemem'