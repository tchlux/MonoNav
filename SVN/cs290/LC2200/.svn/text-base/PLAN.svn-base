===============================
    LRU Memory Management     
===============================

==== WHEN A PROGRAM IS RUN ====

assembled.obj is a machine code file produced by assembler

> assembled.obj
--> Machine does...
delcare int for number of words read
declare an array for holding a single page
 getPage("assembled.obj", 0, PageSize, numWordsRead, OnePage);
 find a physical frame to hold the page (room ? pageNumber : find victim, move to swap if 
                                                             victim page is dirty)
 store the page ( create a stack page if need be )
 set Frame pointer for this program to the first address of that physical page (PC should be 0)
 pushes PCB to ready queue

=== OBSOLETE === 
freeMemory

=== CLASSES WILL NEED ===
Memory:
-> paging

Machine:
-> page table class (two instances, one for RAM and one for swap space)
-> RAM (current memory storage) (instance of Memory)
-> Swap space (add on) (instance of Memory)

Simulator:
->machine.conf file (page size, swap space, stack space = number pages)

=== NEW CLASS MEMBER DATA ===
Machine{
   int PageSize;
}	

PCB{
   int currentVirtualPage; // 0, 1, 2, ...
   int currentStackPage; // 0, 1, 2, ...
}

typedef unsigned long long int ulli;


=== FUNCTIONS ===

//Pre:  fileName null-terminated, 0 < pageNumber < maxPages, 0 < pageSize,
//      numWordsRead is initialized, page is of length pageSize
//Post: This will read through (pageNumber of pageSize words) and extract
//      the appropriate page
void getPage(char * filename, int pageNumber, int pageSize, 
               int & numWordsRead, ulli * page);

//Pre:  There is a page fault
//Post: Returns the frame number of the victim page
int Machine::selectVictimPageLRU();


=============================
     IMPLEMENTATION PLAN     
=============================

=================================
     Phase 1: Reading Config     
=================================

-> Get pageSize, swapSpace, and stackSpace from machine.conf
-> Create place in machine class to hold this information
----> or rather make a function for initializing these values
-> Switch mem and stack specs to number of words in conf file

===========================
    Phase 2: Setup PTE     
===========================

-> Make a PageTableEntry class for holding all information
-> Test PageTableEntry class for proper function
-> Remove Implementation of FreeMemory class from Memory.h
-> Add a loop structure for keeping track of RAM pages with the PTE
   entry class 
-> Add a loop structure for keeping track of  Swap space pages with
   the PTE entry class 

===================================
     Phase 3: Page Swap Policy     
===================================

-> Create a check for the adding of a new page to memory, is there
   space? if so add the page to memory and mark as occupied
-> Find victim page RAM if there is no space, then check swap space
   for the requested page (if it's in swap then put it into RAM in the
   victim page's place.)
-> If that page is dirty, move it to swap space
-> If swap space is full, kill all of that process' ID everywhere
--> Adjust kill to search both tables for the PID to kill

==============================
    Phase 4: Loading Pages   
==============================

-> Translate current PC value to a virtual page number
-> Execute page swap policy
-> Continue running decode cycle
-> Translate all operations involving PC into virtual page numbers and
   then execute page swap policy accordingly to which pages need to be
   accessed.

============================================
   Phase 5: Adding and adjusting commands  
============================================

-> Make jobs display the number of page faults for a program
-> Make displayPageTable show all the page information for the machine


========================
    Phase 1 TESTING     
========================

Test 1: Successful load
memory    16
stack     2
timeslice 3
pagesize  4
swapspace 4

$ ./LC2200
memory		16 words
stack		2 words
time slice	3 instructions
page size	4 words
swapspace	4 pages


Test 2: mem % pagesize != 0, this should exit early
memory    16
stack     2
timeslice 3
pagesize  3
swapspace 4

$ ./LC2200
ERROR: Memory must be divisible by pagesize
$
		
==========================	
     Phase 2: TESTING		
==========================

Test 1:
Test all setters and getters in the PageTableEntry class

Test 2:
Verify that the arrays of PTE's are functional and delete properly
       
==========================	
     Phase 3-5: TESTING     	
==========================	

Test 1:

Test by overflowing the machine.  Run programs in the background
continuosly until all of both RAM and Swap are filled.  The next
process to be run should be immediately killed.

Test 2:

Demonstrate the actual paging by using the displayPageTable command
while RAM and Swap both have pages in the readyQ.  The list of pages
that are currently in RAM and swap should change as each page gets put
on the readyQ and drawn back into RAM. 

Test 3:

Repeat the first test in suspend mode and pay attention to the process
that is chosen to be evicted from RAM, it should be the oldest program.
Be sure to do this in suspend mode, if done in regular operation there
is a chance multiple cycles of page replacement will run before you
can tell what was replaced.